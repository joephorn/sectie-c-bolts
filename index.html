<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Sectie-C Bolts</title>
    <style>
      :root{ --bar-h: 64px; }
      html,body{margin:0;height:100%;background:#fff;}
      body{display:flex;flex-direction:column;height:100vh;}
      #shortcuts{height:var(--bar-h);box-sizing:border-box;padding:10px 14px;display:flex;gap:16px;align-items:center;border-bottom:1px solid #e6e6e6;font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
      #shortcuts .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#f3f3f3; border:1px solid #ddd; border-bottom-color:#ccc; padding:2px 6px; border-radius:6px; box-shadow:inset 0 -1px 0 rgba(0,0,0,.06);} 
      #shortcuts .item{display:flex;align-items:center;gap:8px;white-space:nowrap;}
      #c{flex:1 1 auto; width:100%; height:calc(100vh - var(--bar-h)); display:block;}
    </style>
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/acorn"></script>
    <script type="text/javascript" src="https://unpkg.com/paper"></script>
</head>
<body>
    <div id="shortcuts" role="navigation" aria-label="Shortcuts">
        <div class="item"><span class="kbd" data-key="1">1</span>Line (scroll)</div>
        <div class="item"><span class="kbd" data-key="2">2</span>Line offset</div>
        <div class="item"><span class="kbd" data-key="3">3</span>Arc down</div>
        <div class="item"><span class="kbd" data-key="4">4</span>Arc up</div>
        <div class="item"><span class="kbd" data-key="5">5</span>Circle (scroll)</div>
        <div class="item"><span class="kbd" data-key="6">6</span>> (scroll)</div>
        <div class="item"><span class="kbd" data-key="7">7</span>+</div>
        <div class="item"><span class="kbd" data-key="8">8</span>x</div>
        <div class="item"><span class="kbd" data-key="0">0</span>Begin</div>
        <div class="item"><span class="kbd" id="arrange-ltr" title="Arrange SECTIE‑C along path (Shift/Alt: reverse)" data-key="r">R</span>Arrange</div>

        <div class="item" style="margin-left:auto">
            Jitter
            <input id="jitter" type="range" min="0" max="100" value="100" step="1">
            <span id="jitterVal" class="kbd">100%</span>
        </div>
        <div class="item">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
                <input id="occ-jit" type="checkbox">
                Jitter pulses
            </label>
        </div>
    </div>
    <canvas id="c"></canvas>

    <div id="recorder-ui" style="position:fixed; left:30px; top:80px; z-index:9999; display:flex; gap:8px; font-family:system-ui;">
      <button id="rec-start-webm">Start WebM</button>
      <button id="rec-start-mp4">Start MP4</button>
      <button id="rec-stop" disabled>Stop & download</button>
      <span id="rec-status" style="margin-left:6px; opacity:.75;"></span>
    </div>

    <script>
        (function(){
        const canvas = document.getElementById('c');
        if (!canvas) { console.warn('Canvas #c niet gevonden'); return; }

        // UI
        const btnStartWebM = document.getElementById('rec-start-webm');
        const btnStartMP4  = document.getElementById('rec-start-mp4');
        const btnStop  = document.getElementById('rec-stop');
        const statusEl = document.getElementById('rec-status');

        // Settings
        const FPS = 30;
        const WEBM_TYPES = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8',
            'video/webm'
        ];
        const MP4_TYPES = [
            'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
            'video/mp4'
        ];

        let mediaRecorder = null;
        let chunks = [];
        let stream = null;

        function pickMimeType(list) {
            for (const t of list) {
                if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
            }
            return '';
        }

        function filename(ext) {
            const d = new Date();
            const pad = n => String(n).padStart(2,'0');
            const e = (ext || 'webm').replace(/^\./,'');
            return `recording_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.${e}`;
        }

        function startRecording(preferredList, ext){
            try {
                const type = pickMimeType(preferredList);
                if (!type) {
                    statusEl.textContent = (ext === 'mp4') ? 'MP4 opname niet ondersteund in deze browser.' : 'Recording niet ondersteund.';
                    return;
                }
                // schaal main canvas-buffers voor opname (max ~4k)
                window.dispatchEvent(new CustomEvent('recorder:start', { detail: { targetW: 4096, targetH: 4096, contentScale: 1 } }));
                // stream exact op canvas-resolutie (afhankelijk van jouw canvas.width/height)
                stream = canvas.captureStream(FPS);
                const opts = { mimeType: type };
                // lichte bitrate boost voor kwaliteit
                opts.videoBitsPerSecond = 12_000_000; // ~12 Mbps
                mediaRecorder = new MediaRecorder(stream, opts);
                chunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) chunks.push(e.data);
                };

                mediaRecorder.onstart = () => {
                    if (btnStartWebM) btnStartWebM.disabled = true;
                    if (btnStartMP4)  btnStartMP4.disabled  = true;
                    btnStop.disabled = false;
                    statusEl.textContent = `Recording (${ext.toUpperCase()})…`;
                };

                mediaRecorder.onstop = () => {
                    if (btnStartWebM) btnStartWebM.disabled = false;
                    if (btnStartMP4)  btnStartMP4.disabled  = false;
                    btnStop.disabled = true;
                    statusEl.textContent = '';
                    // herstel canvas buffers
                    window.dispatchEvent(new CustomEvent('recorder:stop'));
                    // bouw blob en download
                    const blob = new Blob(chunks, { type: mediaRecorder.mimeType || (ext === 'mp4' ? 'video/mp4' : 'video/webm') });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename(ext);
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                        a.remove();
                    }, 1000);
                    // cleanup
                    try { stream.getTracks().forEach(t => t.stop()); } catch(_){}
                    stream = null;
                    mediaRecorder = null;
                    chunks = [];
                };

                mediaRecorder.start(250); // timeslice voor vloeiendere write
            } catch (err) {
                console.error('Recorder start error:', err);
                statusEl.textContent = 'Recording niet gestart.';
            }
        }

        if (btnStartWebM) btnStartWebM.addEventListener('click', () => startRecording(WEBM_TYPES, 'webm'));
        if (btnStartMP4)  btnStartMP4.addEventListener('click', () => startRecording(MP4_TYPES, 'mp4'));

        btnStop.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        });

        // handige safety: stop automatisch bij navigatie
        window.addEventListener('beforeunload', () => {
            try { if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop(); } catch(_){}
            try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch(_){}
        });
        })();
        </script>
    <script src="./script.js"></script>
</body>
</html>
