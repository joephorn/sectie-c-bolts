<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Sectie-C Bolts</title>
    <style>
      :root{ --bar-h: 64px; }
      html,body{margin:0;height:100%;background:#fff;overflow: hidden;}
      body{display:flex;flex-direction:column;height:100vh;}
      #shortcuts{height:var(--bar-h);box-sizing:border-box;padding:10px 14px;display:flex;gap:16px;align-items:center;border-bottom:1px solid #e6e6e6;font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
      .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#f3f3f3; border:1px solid #ddd; border-bottom-color:#ccc; padding:2px 6px; border-radius:6px; box-shadow:inset 0 -1px 0 rgba(0,0,0,.06);}
      .kbd.active{ background:#16a34a; color:#fff; border-color:#0e7a36; }
      .kbd[disabled]{ opacity:.5; cursor:not-allowed; }
      #shortcuts .item{display:flex;align-items:center;gap:8px;white-space:nowrap;}
      #c{flex:1 1 auto; width:100%; height:calc(100vh - var(--bar-h)); display:block;}
    </style>
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/acorn"></script>
    <script type="text/javascript" src="https://unpkg.com/paper"></script>
    <!-- JSZip (zip PNG sequence) -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

</head>
<body>
    <div id="shortcuts" role="navigation" aria-label="Shortcuts">
        <div class="item"><span class="kbd" data-key="1">1</span>Line (scroll)</div>
        <div class="item"><span class="kbd" data-key="2">2</span>Line offset</div>
        <div class="item"><span class="kbd" data-key="3">3</span>Arc down</div>
        <div class="item"><span class="kbd" data-key="4">4</span>Arc up</div>
        <div class="item"><span class="kbd" data-key="5">5</span>Circle (scroll)</div>
        <div class="item"><span class="kbd" data-key="6">6</span>> (scroll)</div>
        <div class="item"><span class="kbd" data-key="7">7</span>+</div>
        <div class="item"><span class="kbd" data-key="8">8</span>x</div>
        <div class="item"><span class="kbd" data-key="0">0</span>Begin</div>
        <div class="item"><span class="kbd" id="arrange-ltr" title="Arrange SECTIE‑C along path (Shift/Alt: reverse)" data-key="r">R</span>Reverse path</div>
        <div class="item"><span class="kbd" data-key="left-mouse">Lmouse</span>Random rotation</div>
        <div class="item"><span class="kbd" data-key="space">Space</span>Rotate C</div>
        <div class="item"><span class="kbd" id="toggle-bg" title="Witte achtergrond togglen" data-key="b">BG</span>Witte achtergrond</div>
    </div>
    <canvas id="c"></canvas>

    <div id="recorder-ui shortcuts" style="position:fixed; left:30px; top:80px; z-index:9999; display:flex; gap:8px;">
      <span class="kbd" id="export-svg" title="Exporteer als SVG">Export SVG</span>
      <button class="kbd" id="export-png-seq" title="Exporteer PNG sequence (alpha)">Export PNG seq</button>
      <button class="kbd" id="rec-start-webm">Start WebM</button>
      <button class="kbd" id="rec-start-mp4">Start MP4</button>
      <button class="kbd" id="rec-start-dual" title="2× WebM (color+matte), 2K vierkant">Start Color+Matte</button>
      <button class="kbd" id="rec-stop" disabled>Stop & download</button>
    </div>

    <script>
        (function(){
        const canvas = document.getElementById('c');
        if (!canvas) { console.warn('Canvas #c niet gevonden'); return; }

        // UI
        const btnStartWebM = document.getElementById('rec-start-webm');
        const btnStartMP4  = document.getElementById('rec-start-mp4');
        const btnStartDual = document.getElementById('rec-start-dual');
        const btnPngSeq    = document.getElementById('export-png-seq');
        const btnStop  = document.getElementById('rec-stop');

        // Settings
        const FPS = 30;
        const WEBM_TYPES = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8',
            'video/webm'
        ];
        const MP4_TYPES = [
            'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
            'video/mp4'
        ];

        let mediaRecorder = null;
        let chunks = [];
        let stream = null;
        // Dual-pass (color+matte) state
        let dualState = { running:false, cancel:null };

        function pickMimeType(list) {
            for (const t of list) {
                if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
            }
            return '';
        }

        function filename(ext) {
            const d = new Date();
            const pad = n => String(n).padStart(2,'0');
            const e = (ext || 'webm').replace(/^\./,'');
            return `recording_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.${e}`;
        }
        function filenameDual(kind){
            const d = new Date();
            const pad = n => String(n).padStart(2,'0');
            const k = kind || 'color';
            return `sectie-c_${k}_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.webm`;
        }

        function startRecording(preferredList, ext){
            try {
                const type = pickMimeType(preferredList);
                if (!type) { console.warn(ext === 'mp4' ? 'MP4 opname niet ondersteund.' : 'Recording niet ondersteund.'); return; }
                // schaal main canvas-buffers voor opname (max ~4k)
                window.dispatchEvent(new CustomEvent('recorder:start', { detail: { targetW: 4096, targetH: 4096, contentScale: 1 } }));
                // stream exact op canvas-resolutie (afhankelijk van jouw canvas.width/height)
                stream = canvas.captureStream(FPS);
                const opts = { mimeType: type };
                // lichte bitrate boost voor kwaliteit
                opts.videoBitsPerSecond = 12_000_000; // ~12 Mbps
                mediaRecorder = new MediaRecorder(stream, opts);
                chunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) chunks.push(e.data);
                };

                mediaRecorder.onstart = () => {
                    if (btnStartWebM) btnStartWebM.disabled = true;
                    if (btnStartMP4)  btnStartMP4.disabled  = true;
                    if (btnPngSeq) btnPngSeq.disabled = true;
                    btnStop.disabled = false;
                    // highlight active start button
                    try {
                      if (btnStartWebM) btnStartWebM.classList.remove('active');
                      if (btnStartMP4)  btnStartMP4.classList.remove('active');
                      if (ext === 'webm' && btnStartWebM) btnStartWebM.classList.add('active');
                      if (ext === 'mp4'  && btnStartMP4)  btnStartMP4.classList.add('active');
                    } catch(_){}
                };

                mediaRecorder.onstop = () => {
                    if (btnStartWebM) btnStartWebM.disabled = false;
                    if (btnStartMP4)  btnStartMP4.disabled  = false;
                    if (btnPngSeq) btnPngSeq.disabled = false;
                    btnStop.disabled = true;
                    // clear active highlight
                    try {
                      if (btnStartWebM) btnStartWebM.classList.remove('active');
                      if (btnStartMP4)  btnStartMP4.classList.remove('active');
                    } catch(_){}
                    // herstel canvas buffers
                    window.dispatchEvent(new CustomEvent('recorder:stop'));
                    // bouw blob en download
                    const blob = new Blob(chunks, { type: mediaRecorder.mimeType || (ext === 'mp4' ? 'video/mp4' : 'video/webm') });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename(ext);
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                        a.remove();
                    }, 1000);
                    // cleanup
                    try { stream.getTracks().forEach(t => t.stop()); } catch(_){}
                    stream = null;
                    mediaRecorder = null;
                    chunks = [];
                };

                mediaRecorder.start(250); // timeslice voor vloeiendere write
            } catch (err) {
                console.error('Recorder start error:', err);
            }
        }

        if (btnStartWebM) btnStartWebM.addEventListener('click', () => startRecording(WEBM_TYPES, 'webm'));
        if (btnStartMP4)  btnStartMP4.addEventListener('click', () => startRecording(MP4_TYPES, 'mp4'));
        if (btnStartDual) btnStartDual.addEventListener('click', startDualRecording2k);

        // --- Export PNG sequence (alpha) into ZIP ---
        function _dataURLToBlob(dataUrl){
            const parts = dataUrl.split(',');
            const mime = parts[0].match(/:(.*?);/)[1] || 'image/png';
            const bin = atob(parts[1]);
            const len = bin.length;
            const arr = new Uint8Array(len);
            for (let i=0;i<len;i++) arr[i] = bin.charCodeAt(i);
            return new Blob([arr], { type: mime });
        }

        async function exportPngSequence(){
            try {
                if (typeof JSZip === 'undefined') { console.warn('JSZip niet beschikbaar.'); return; }
                const fpsStr = prompt('FPS voor export (5–60):', String(FPS));
                if (fpsStr == null) return;
                let fps = Math.max(5, Math.min(60, Math.floor(Number(fpsStr)||FPS)));
                const secStr = prompt('Aantal seconden (1–30):', '3');
                if (secStr == null) return;
                let secs = Math.max(1, Math.min(30, Math.floor(Number(secStr)||3)));
                const do4k = confirm('Opschalen naar ~4K canvas? Dit kan veel geheugen gebruiken. OK = ja, Cancel = nee.');

                btnPngSeq && (btnPngSeq.disabled = true);
                btnStop && (btnStop.disabled = true);
                btnStartWebM && (btnStartWebM.disabled = true);
                btnStartMP4 && (btnStartMP4.disabled = true);
                

                if (do4k) window.dispatchEvent(new CustomEvent('recorder:start', { detail: { targetW: 4096, targetH: 4096, contentScale: 1 } }));
                const prevBg = (typeof window._sc_getBgEnabled === 'function') ? !!window._sc_getBgEnabled() : null;
                try { if (typeof window._sc_setBgEnabled === 'function') window._sc_setBgEnabled(false); } catch(_){}

                const total = fps * secs;
                const frameDur = 1000 / fps;
                const zip = new JSZip();
                const start = (performance && performance.now) ? performance.now() : Date.now();
                let nextTs = start;
                for (let i=0;i<total;i++){
                    const now = (performance && performance.now) ? performance.now() : Date.now();
                    const wait = Math.max(0, nextTs - now);
                    if (wait > 0) await new Promise(r => setTimeout(r, wait));
                    await new Promise(r => requestAnimationFrame(() => setTimeout(r, 0)));
                    const blob = await new Promise(res => {
                        try {
                            canvas.toBlob(b => res(b || _dataURLToBlob(canvas.toDataURL('image/png'))), 'image/png');
                        } catch(_) {
                            try { res(_dataURLToBlob(canvas.toDataURL('image/png'))); } catch(e){ res(null); }
                        }
                    });
                    if (blob) zip.file(`sectiec_${String(i).padStart(4,'0')}.png`, blob);
                    nextTs += frameDur;
                }

                const zipBlob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                const d = new Date();
                const pad = n => String(n).padStart(2,'0');
                const name = `sectie-c_pngseq_${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}.zip`;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 1000);

                try { window.dispatchEvent(new CustomEvent('recorder:stop')); } catch(_){}
                try { if (typeof prevBg === 'boolean' && typeof window._sc_setBgEnabled === 'function') window._sc_setBgEnabled(prevBg); } catch(_){}
            } catch (err) {
                console.error('PNG sequence export error:', err);
            } finally {
                btnPngSeq && (btnPngSeq.disabled = false);
                btnStop && (btnStop.disabled = true);
                btnStartWebM && (btnStartWebM.disabled = false);
                btnStartMP4 && (btnStartMP4.disabled = false);
                
            }
        }

        if (btnPngSeq) btnPngSeq.addEventListener('click', exportPngSequence);

        // --- Dual WebM (color + matte) at ~2K square using MediaRecorder ---
        function createCanvas(w, h){ const c = document.createElement('canvas'); c.width = w; c.height = h; return c; }
        function drawLetterboxed(dstCtx, srcCanvas, outW, outH, bgColor){
            dstCtx.clearRect(0,0,outW,outH);
            const sw = srcCanvas.width, sh = srcCanvas.height;
            const scale = Math.min(outW/sw, outH/sh);
            const dw = Math.round(sw*scale), dh = Math.round(sh*scale);
            const dx = Math.floor((outW - dw)/2), dy = Math.floor((outH - dh)/2);
            dstCtx.drawImage(srcCanvas, 0, 0, sw, sh, dx, dy, dw, dh);
            if (bgColor){
                dstCtx.save();
                dstCtx.globalCompositeOperation = 'destination-over';
                dstCtx.fillStyle = bgColor; // typically black
                dstCtx.fillRect(0,0,outW,outH);
                dstCtx.restore();
            }
            return {dx,dy,dw,dh};
        }

        function makeMatte(dstCtx, outW, outH){
            // Replace RGB with white where alpha>0, then put black background behind
            dstCtx.save();
            dstCtx.globalCompositeOperation = 'source-in';
            dstCtx.fillStyle = '#ffffff';
            dstCtx.fillRect(0,0,outW,outH);
            dstCtx.globalCompositeOperation = 'destination-over';
            dstCtx.fillStyle = '#000000';
            dstCtx.fillRect(0,0,outW,outH);
            dstCtx.restore();
        }

        function startDualRecording2k(){
            try {
                const OUT = 2048; // 2K vierkant
                // Prepare UI
                if (btnStartWebM) btnStartWebM.disabled = true;
                if (btnStartMP4)  btnStartMP4.disabled  = true;
                
                if (btnPngSeq) btnPngSeq.disabled = true;
                if (btnStartDual) btnStartDual.disabled = true, btnStartDual.classList.add('active');
                btnStop.disabled = false;

                // Upscale buffers moderately so source has enough detail
                window.dispatchEvent(new CustomEvent('recorder:start', { detail: { targetW: OUT, targetH: OUT, contentScale: 1 } }));
                const hadBg = (typeof window._sc_getBgEnabled === 'function') ? !!window._sc_getBgEnabled() : null;
                try { if (typeof window._sc_setBgEnabled === 'function') window._sc_setBgEnabled(false); } catch(_){}

                // Offscreen canvases
                const cColor = createCanvas(OUT, OUT);
                const xColor = cColor.getContext('2d', { alpha: true });
                const cMatte = createCanvas(OUT, OUT);
                const xMatte = cMatte.getContext('2d', { alpha: true });

                // Streams and recorders
                const sColor = cColor.captureStream(30);
                const sMatte = cMatte.captureStream(30);
                const chunksColor = [], chunksMatte = [];
                const opts = { mimeType: (MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm'), videoBitsPerSecond: 12_000_000 };
                const recColor = new MediaRecorder(sColor, opts);
                const recMatte = new MediaRecorder(sMatte, opts);
                recColor.ondataavailable = e => { if (e.data && e.data.size) chunksColor.push(e.data); };
                recMatte.ondataavailable = e => { if (e.data && e.data.size) chunksMatte.push(e.data); };

                // Pump frames into offscreen targets
                let running = true;
                function tick(){
                    if (!running) return;
                    drawLetterboxed(xColor, canvas, OUT, OUT, '#000');
                    drawLetterboxed(xMatte, canvas, OUT, OUT, null);
                    makeMatte(xMatte, OUT, OUT);
                    requestAnimationFrame(tick);
                }
                requestAnimationFrame(tick);

                recColor.start(250);
                recMatte.start(250);
                dualState.running = true;
                dualState.cancel = () => {
                    if (!running) return;
                    running = false;
                    try { recColor.stop(); } catch(_){}
                    try { recMatte.stop(); } catch(_){}
                };

                // Finalize on both stop
                let stoppedCount = 0;
                function maybeFinish(){
                    stoppedCount++;
                    if (stoppedCount < 2) return;
                    // Save files
                    const blobC = new Blob(chunksColor, { type: opts.mimeType });
                    const blobM = new Blob(chunksMatte, { type: opts.mimeType });
                    const urlC = URL.createObjectURL(blobC);
                    const urlM = URL.createObjectURL(blobM);
                    const a1 = document.createElement('a'); a1.href = urlC; a1.download = filenameDual('color'); document.body.appendChild(a1); a1.click(); setTimeout(() => { URL.revokeObjectURL(urlC); a1.remove(); }, 1000);
                    const a2 = document.createElement('a'); a2.href = urlM; a2.download = filenameDual('matte'); document.body.appendChild(a2); a2.click(); setTimeout(() => { URL.revokeObjectURL(urlM); a2.remove(); }, 1000);

                    // Restore UI/state
                    try { window.dispatchEvent(new CustomEvent('recorder:stop')); } catch(_){}
                    try { if (typeof hadBg === 'boolean' && typeof window._sc_setBgEnabled === 'function') window._sc_setBgEnabled(hadBg); } catch(_){}
                    if (btnStartWebM) btnStartWebM.disabled = false;
                    if (btnStartMP4)  btnStartMP4.disabled  = false;
                    
                    if (btnPngSeq) btnPngSeq.disabled = false;
                    if (btnStartDual) { btnStartDual.disabled = false; btnStartDual.classList.remove('active'); }
                    btnStop.disabled = true;
                    dualState.running = false; dualState.cancel = null;
                }
                recColor.onstop = maybeFinish;
                recMatte.onstop = maybeFinish;
            } catch (err) {
                console.error('Dual recorder error:', err);
                alert('Kon Color+Matte opname niet starten. Zie console.');
            }
        }

        btnStop.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                return;
            }
            
            if (dualState && dualState.running && typeof dualState.cancel === 'function') {
                dualState.cancel();
                return;
            }
        });

        // handige safety: stop automatisch bij navigatie
        window.addEventListener('beforeunload', () => {
            try { if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop(); } catch(_){}
            try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch(_){}
        });
        })();
        </script>
    <script src="./script.js"></script>
</body>
</html>
